/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/spf13/pflag"
)

// This program provides quick-and-dirty codegen for legacyflag helpers.

var (
	configPath = pflag.String("config", "", "path to a json file containing a Config")
)

// Config is the overall config that drives codegen
type Config struct {
	// Package is the target package where generated Go files should be created.
	Package string
	// Types are the types to generate Go files for.
	Types []TypeConfig

	// Absolute path to the package dir. This is where we save generated files.
	pkgPath string
	// Name of the package. Used for "package" statement at the top of files.
	pkgName string
}

// TypeConfig is the codegen config for a single type
type TypeConfig struct {
	// Qualified Go name of the type
	Type string
	// Name of the type in pflag, e.g. []int may be named IntSlice.
	Name string
	// Import path for the package containing Type
	ImportPath string

	// Generated tests:
	// String flag input to test
	TestFlagInput string
	// Raw Go string result of Set operation
	TestSetResult string
}

// Pass paths to files from the command line
func main() {
	pflag.Parse()
	if *configPath == "" {
		fmt.Fprintln(os.Stderr, pflag.CommandLine.FlagUsages())
		os.Exit(1)
	}
	c := &Config{}
	if err := c.Parse(*configPath); err != nil {
		fmt.Fprintln(os.Stderr, "Error:", err)
		os.Exit(1)
	}
	if err := c.Gen(); err != nil {
		fmt.Fprintln(os.Stderr, "Error:", err)
		os.Exit(1)
	}
}

// Parse parses the file at path into the config.
func (c *Config) Parse(path string) error {
	b, err := ioutil.ReadFile(path)
	if err != nil {
		return err
	}
	if err := json.Unmarshal(b, c); err != nil {
		return err
	}
	// figure out the absolute path to the package dir
	goPath := os.Getenv("GOPATH")
	if goPath == "" {
		return fmt.Errorf("GOPATH not set")
	}
	c.pkgPath = filepath.Join(goPath, "src", c.Package)
	c.pkgName = filepath.Base(c.pkgPath)
	return nil
}

// Gen generates based on Config
func (c *Config) Gen() error {
	for _, t := range c.Types {
		if err := t.Gen(c.pkgName, c.pkgPath); err != nil {
			return err
		}
	}
	return nil
}

// Gen generates based on TypeConfig
func (t *TypeConfig) Gen(pkgName, pkgPath string) error {
	if len(t.Type) > 2 && t.Type[:2] == "[]" {
		if err := t.gen(pkgName, pkgPath, sliceTmpl, false); err != nil {
			return nil
		}
		if err := t.gen(pkgName, pkgPath, testTmpl, true); err != nil {
			return nil
		}
	} else {
		if err := t.gen(pkgName, pkgPath, basicTmpl, false); err != nil {
			return nil
		}
		if err := t.gen(pkgName, pkgPath, testTmpl, true); err != nil {
			return nil
		}
	}
	return nil
}

func (t *TypeConfig) gen(pkgName, pkgPath string, tmpl *template.Template, test bool) error {
	out := outPath(pkgPath, t.Type, test)
	data := tmplData{
		PkgName:    pkgName,
		TypeConfig: *t,
	}
	file, err := os.Create(out)
	if err != nil {
		return err
	}
	if err := tmpl.Execute(file, data); err != nil {
		return err
	}
	return nil
}

func outPath(pkgPath, t string, test bool) string {
	suffix := ".go"
	if test {
		suffix = "_test.go"
	}

	if len(t) > 2 && t[:2] == "[]" {
		t = t[2:] + "_slice"
	}

	return filepath.Join(pkgPath,
		strings.ToLower(strings.ReplaceAll(t, ".", "_")+suffix))
}

const license = `/*
Copyright {YEAR} The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/`

func licenseWithYear() string {
	return strings.Replace(license, "{YEAR}", time.Now().Format("2006"), 1)
}

const genwarning = "// This file is generated by hack/gen/gen.go. DO NOT EDIT."

func withHeader(s string) string {
	return fmt.Sprintf("%s\n\n%s\n\n%s", licenseWithYear(), genwarning, s)
}

type tmplData struct {
	PkgName string

	TypeConfig
}

var basicTmpl = template.Must(template.New("basic").Parse(withHeader(basicTmplRaw)))

const basicTmplRaw = `package legacyflag

import(
	"github.com/spf13/pflag"
	{{if .ImportPath}}"{{.ImportPath}}"{{end}}
)

// {{.Name}}Value is a reference to a registered {{.Type}} flag value.
type {{.Name}}Value struct {
	name string
	value {{.Type}}
	fs *pflag.FlagSet
}

// {{.Name}}Var registers a flag for {{.Type}} against the FlagSet, and returns
// a {{.Name}}Value reference to the registered flag value.
func (fs *FlagSet) {{.Name}}Var(name string, def {{.Type}}, usage string) *{{.Name}}Value {
	v := &{{.Name}}Value{
		name: name,
		fs: fs.fs,
	}
	fs.fs.{{.Name}}Var(&v.value, name, def, usage)
	return v
}

// Set copies the flag value to the target if the flag was set.
func (v *{{.Name}}Value) Set(target *{{.Type}}) {
	if v.fs.Changed(v.name) {
		*target = v.value
	}
}

// Apply calls the apply func with the flag value if the flag was set.
func (v *{{.Name}}Value) Apply(apply func(value {{.Type}})) {
	if v.fs.Changed(v.name) {
		apply(v.value)
	}
}
`

var sliceTmpl = template.Must(template.New("slice").Parse(withHeader(sliceTmplRaw)))

const sliceTmplRaw = `package legacyflag

import(
	"github.com/spf13/pflag"
	{{if .ImportPath}}"{{.ImportPath}}"{{end}}
)

// {{.Name}}Value is a reference to a registered {{.Type}} flag value.
type {{.Name}}Value struct {
	name string
	value {{.Type}}
	fs *pflag.FlagSet
}

// {{.Name}}Var registers a flag for {{.Type}} against the FlagSet, and
// returns a {{.Name}}Value reference to the registered flag value.
func (fs *FlagSet) {{.Name}}Var(name string, def {{.Type}}, usage string) *{{.Name}}Value {
	v := &{{.Name}}Value{
		name: name,
		fs: fs.fs,
	}
	fs.fs.{{.Name}}Var(&v.value, name, def, usage)
	return v
}

// Set copies the flag value to the target if the flag was set.
func (v *{{.Name}}Value) Set(target *{{.Type}}) {
	if v.fs.Changed(v.name) {
		*target = make({{.Type}}, len(v.value))
		copy(*target, v.value)
	}
}

// Apply calls the apply func with the flag value if the flag was set.
func (v *{{.Name}}Value) Apply(apply func(value {{.Type}})) {
	if v.fs.Changed(v.name) {
		apply(v.value)
	}
}
`

var testTmpl = template.Must(template.New("basic_test").Parse(withHeader(testTmplRaw)))

const testTmplRaw = `package legacyflag

import(
	"testing"
	"reflect"
	{{if .ImportPath}}"{{.ImportPath}}"{{end}}
)

func Test{{.Name}}Var(t *testing.T) {
	cases := []struct {
		name string
		args []string
		set   {{.Type}}
		apply bool
	}{
		{
			name: "flag is set",
			args: []string{"--foo={{.TestFlagInput}}"},
			set: {{.TestSetResult}},
			apply: true,
		},
		{
			name: "flag is not set",
			args: []string{""},
			apply: false,
		},
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			var target {{.Type}}

			fs := NewFlagSet("")
			val := fs.{{.Name}}Var("foo", target, "")
			if err := fs.Parse(c.args); err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			val.Set(&target)
			if !reflect.DeepEqual(target, c.set) {
				t.Errorf("Set: got %#v but expected %#v", target, c.set)
			}

			applied := false
			val.Apply(func(value {{.Type}}) {
				applied = true
				// value passed to apply func should match the expected result of Set
				if !reflect.DeepEqual(value, c.set) {
					t.Errorf("Apply: got %#v but expected %#v", value, c.set)
				}
			})
			if c.apply && !applied {
				t.Errorf("Apply: apply func not called")
			} else if !c.apply && applied {
				t.Errorf("Apply: apply func called, should not have been")
			}
		})
	}
}
`
